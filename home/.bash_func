############################################################
# functions
############################################################
function swap()     # Swap 2 filenames around, if they exist
{
  local TMPFILE=tmp.$$

  [ $# -ne 2 ] && echo "swap: 2 arguments needed" && return 1
  [ ! -e $1 ] && echo "swap: $1 does not exist" && return 1
  [ ! -e $2 ] && echo "swap: $2 does not exist" && return 1

  mv "$1" $TMPFILE
  mv "$2" "$1"
  mv $TMPFILE "$2"
}

function lowercase()  # move filenames to lowercase
{
  for file ; do
    filename=${file##*/}
    case "$filename" in
    */*) dirname==${file%/*} ;;
    *) dirname=.;;
    esac
    nf=$(echo $filename | tr A-Z a-z)
    newname="${dirname}/${nf}"
    if [ "$nf" != "$filename" ]; then
      mv "$file" "$newname"
      echo "lowercase: $file --> $newname"
    else
      echo "lowercase: $file not changed."
    fi
  done
}

function no_spaces()
{
  for file ; do
    filename=${file##*/}
    case "$filename" in
    */*) dirname==${file%/*} ;;
    *) dirname=.;;
    esac
    nf=$(echo $filename | sed -E 's/[[:space:]]+/_/g')
    newname="${dirname}/${nf}"
    if [ "$nf" != "$filename" ]; then
      mv "$file" "$newname"
      echo "no_spaces: $file --> $newname"
    else
      echo "no_spaces: $file not changed."
    fi
  done
}

function nuke_spaces()
{
  ruby -e 'files = Dir["./*"].select { |file| file.match(/ /) }
    files.each do |file|
      newname = file.gsub(/ /, "_")
      puts "nuke_spaces: #{file} --> #{newname}"
      File.rename(file, newname)
    end'
}

function repeat()     # Repeat n times command
{
  local i max
  max=$1; shift;
  for ((i=1; i <= max ; i++)); do
    eval "$@";
  done
}

function extract()    # Handy Extract Program
{
   if [ -f $1 ] ; then
     case $1 in
       *.tar.bz2)   tar xvjf $1   ;;
       *.tar.gz)  tar xvzf $1   ;;
       *.bz2)     bunzip2 $1    ;;
       *.rar)     unrar x $1    ;;
       *.gz)    gunzip $1     ;;
       *.tar)     tar xvf $1    ;;
       *.tbz2)    tar xvjf $1   ;;
       *.tgz)     tar xvzf $1   ;;
       *.zip)     unzip $1    ;;
       *.Z)     uncompress $1   ;;
       *.7z)    7z x $1     ;;
       *)       echo "'$1' cannot be extracted via >extract<" ;;
     esac
   else
     echo "'$1' is not a valid file"
   fi
}

function dirsize()
{
  du -shx * .[a-zA-Z0-9_]* 2> /dev/null | \
  egrep '^ *[0-9.]*[MG]' | sort -n > /tmp/list
  egrep '^ *[0-9.]*M' /tmp/list
  egrep '^ *[0-9.]*G' /tmp/list
  rm -f /tmp/list
}

function find_exec()   # Find a file with pattern $1 in name and Execute $2 on it
{
  # Check for proper number of command line args.
  EXPECTED_ARGS=2

  if [ $# -ne $EXPECTED_ARGS ]; then
    echo "ERROR: invaild # of args: Usage: fe pattern cmd"
  else
    find . -type f -iname '*'$1'*' -exec "${2:-file}" {} \;  ;
  fi
}

function add_path()    # Temporarily add directories to PATH
{
  if [ $# -lt 1 ] || [ $# -gt 2 ]; then
    echo "Temporarily add to PATH"
    echo "usage: apath [dir]"
  else
    PATH=$1:$PATH
  fi
}

function my_ps() { ps $@ -u $USER -o pid,%cpu,%mem,bsdtime,command ; }

function killps()         # Kill by process name
{
  local pid pname sig="-TERM"   # Default signal
  if [ "$#" -lt 1 ] || [ "$#" -gt 2 ]; then
    echo "Usage: killps [-SIGNAL] pattern"
    return;
  fi
  if [ $# = 2 ]; then sig=$1 ; fi
  for pid in $(my_ps| awk '!/awk/ && $0~pat { print $1 }' pat=${!#} ) ; do
    pname=$(my_ps | awk '$1~var { print $5 }' var=$pid )
    if ask "Kill process $pid <$pname> with signal $sig?"
#      then kill -9 $sig $pid
      then kill -9 $pid
    fi
  done
}

function ask()
{
  echo -n "${RED}$@" '[y/n] ' "${RESET}" ; read ans
  case "$ans" in
    y*|Y*) return 0 ;;
    *) return 1 ;;
  esac
}

function my_ip()    # Get IP address
{
  MY_IP=$(/sbin/ifconfig | awk '/inet/ { print $2 } ' | sed -e s/addr://)
}

function hi()       # Get current host related info
{
  echo -e "${RED}You are logged on:${RESET}" ; hostname
  echo -e "\n${RED}Additionnal information:${RESET}" ; uname -a
  echo -e "\n${RED}Current date :${RESET} " ; date
  echo -e "\n${RED}Machine stats :${RESET}" ; uptime
  echo -e "\n${RED}Memory stats :${RESET}" ; free
  echo -e "\n${RED}Disk stats :${RESET}" ; df -kh
  my_ip 2>&- ;
  echo -e "\n${RED}Local IP Address :${RESET}" ; echo ${MY_IP:-"Not connected"}
  echo -e "\n${YELLOW}Users logged on:${RESET}" ; w -h
}

function ni()       # network information
{
  echo "--------------- Network Information ---------------"
  /sbin/ifconfig
  echo "---------------------------------------------------"
  echo -e "\nOpen connections : "; netstat;
}

function bash_stat()
{
  cut -f1 -d" " $HOME/.bash_history | sort | uniq -c | sort -nr | head -n 10
}

alias hideme='history -d $((HISTCMD-1)) &&' $1

function containsElement () {
  local e
  for e in "${@:2}"; do
    if [[ "$e" == "$1" ]]; then
      echo 1
      return 0 # bash exit code
      fi
  done
  echo 0
  return 1 # bash exit code
}

function clock()
{
  night_hours=('22' '23' '00' '01' '02' '03')
  Cnight_hours=('19' '20' '21' '04' '05' '06')
  while true; do
  xit='null'
  echo "${INVIS}"; read -s -t 1 -n 1 xit
  if [ "$xit" == "q" ]; then
    echo "Good-bye?!${RESET}"; sleep 1; clear; echo "${VIS}"
    break
  else
    clear
    timet=$(date +"%R" | sed -E 's/(.{2})/\1 /g' | awk /'/ {print $1}')

    if [[ $(containsElement "$timet" "${night_hours[@]}") -eq 1 ]]; then echo "${GREEN}"
    elif [[ $(containsElement "$timet" "${Cnight_hours[@]}") -eq 1 ]]; then echo "${BLUE}"
    else echo "${YELLOW}"
    fi
    echo "==================================="
    echo "=========== $(date +"%r") ==========="
    echo "==================================="
  fi
  done
}

function shot()     # Takes a screenshot of your size choice
{
  import -frame -strip -quality 75 "$HOME/$(date +%s).png"
}

# Creates an archive from given directory
mktar() { tar cvf  "${1%%/}.tar"   "${1%%/}/"; }
mktgz() { tar cvzf "${1%%/}.tar.gz"  "${1%%/}/"; }
mktbz() { tar cvjf "${1%%/}.tar.bz2" "${1%%/}/"; }

function colortest()
{
  # set colors
  echo "${BLACK} TEST test ${TXTBLD} TEST test ${RESET}"
  echo "${RED} TEST test ${TXTBLD} TEST test ${RESET}"
  echo "${GREEN} TEST test ${TXTBLD} TEST test ${RESET}"
  echo "${YELLOW} TEST test ${TXTBLD} TEST test ${RESET}"
  echo "${BLUE} TEST test ${TXTBLD} TEST test ${RESET}"
  echo "${PURPLE} TEST test ${TXTBLD} TEST test ${RESET}"
  echo "${CYAN} TEST test ${TXTBLD} TEST test ${RESET}"
  echo "${WHITE} TEST test ${TXTBLD} TEST test ${RESET}"
}

function colortest2() {
  for i in {0..255} ; do
    printf "\x1b[38;5;${i}mcolour${i}\n"
  done
}

function trans()
{
  awk '
  {
  for (i=1; i<=NF; i++)  {
    a[NR,i] = $i
  }
  }
  NF>p { p = NF }
  END {
  for(j=1; j<=p; j++) {
    str=a[1,j]
    for(i=2; i<=NR; i++){
    str=str" "a[i,j];
    }
    print str
  }
  }' $1
}

function add_col_rows()
{
  awk '{total = total + $1}END{print total}' $1
}

function spl() {
  mysql -e 'show processlist' | egrep $1
}

function mysql_find_col() {
  EXPECTED_ARGS=2
  if [ $# -ne $EXPECTED_ARGS ]; then
    echo "ERROR invalid # of args"
    echo "Usage: `basename $0` DBs cols"
    return 65
  fi

  echo "mysql_find_col: searching dbs:$1 for $2"
  mysql -e "SELECT TABLE_SCHEMA, TABLE_NAME, group_concat(COLUMN_NAME) MATCHING_COLUMNS \
    FROM INFORMATION_SCHEMA.COLUMNS \
    WHERE COLUMN_NAME regexp '$2' \
      and TABLE_SCHEMA regexp '$1' \
    group by 1, 2;"
}

function watch_proc() {
  sleepy_time=1
  while true; do
    clear
    eval $*
    sleep $sleepy_time
  done
}

export GRC=`which grc 2>/dev/null`
if [ "$TERM" != dumb ] && [ -n GRC ]
then
  alias colourify="$GRC -es --colour=auto"
  alias mvn="colourify -c $HOME/.grc/mvn.config mvn"
  alias kat="colourify -c $HOME/.grc/mvn.config"
fi
